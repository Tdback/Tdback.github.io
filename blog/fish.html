<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Learning Fish: Sacrificing Compatibility for a Better Shell Experience</title>
<meta name="generator" content="Org mode" />
</head>
<body>
<div id="content">
<h1 class="title">Learning Fish: Sacrificing Compatibility for a Better Shell Experience</h1>
<p>
Date: Apr 26, 2023
</p>

<p>
Over the past few years of using both Linux- and Unix-based systems, I have spent very little investment in exploring the various shell programs that are available to the user. I have always defaulted to the pre-installed Bash shell (or Zsh when using OS X) which I've used to accomplish nearly all of my terminal work. There was a brief period when daily-driving a MacBook Pro that I extended the functionality of the Zsh shell using <a href="https://ohmyz.sh">oh-my-zsh</a>, a popular framework for managing the customization of the Zsh shell, to add autosuggestions and provide other utilities not available out of the box. But, after experiencing some issues with loading times (which is an issue considering I'm a performance nut when it comes to things like my terminal) I decided to remove oh-my-zsh from my shell and opt to using other utilities like <a href="https://starship.rs">starship.rs</a> to customize my terminal prompt. At the time I also didn't fully utilize autosuggestions, so I simply opted to using the built-in tab-completions and remove the extension altogether. 
</p>

<p>
It wasn't until recently that I began to further explore my shell and the various programs available that I could use to interact with my computer. For those who aren't familiar, a shell is simply an interface to the operating system and its underlying kernel, allowing a user to execute commands, run programs, call shell scripts, and view their output. A user uses a terminal emulator (alacritty in my case), which runs a particular shell, to interact with the shell via a text interface. There are several shells available, including Bash, Zsh, fish, PowerShell, cmd.exe, Emacs shell, and Nushell to name a few (in fact, this only covers the shells that I've used personally: there are many more!). When I first set up my Arch Linux system, I opted to use Zsh instead of Bash (the default on most Linux distros) since there were a few plugins I found to be particularly useful: syntax highlighting, history substring search, and of course autosuggestions. This is not to say that Bash didn't also have these plugins available, I just found it easier to set up in my Zsh configuration. It was around this time that I began to take scripting more seriously, and I began teaching myself more of the Bash scripting language to automate more of my workflow. One day, I stumbled across a follow-up to another video titled <a href="https://www.youtube.com/watch?v=lq98MM2ogBk">"bash's echo command is broken"</a>, which discussed some more granular details regarding Bash's implementation of the echo command. I had seen the original video before, just a couple of months prior, but I decided to watch it again to refresh my memory on the subject since I enjoy learning weird quirks about the Linux shell environment. It was in this video that the host mentioned using the fish shell, an alternative to both Bash and Zsh. I had only heard of the fish shell on very few occasions prior to this point, including when I first watched the original video, so I was intrigued as to what it was. I quickly installed it with <code>sudo pacman -S fish</code>, ran <code>fish</code> to launch the shell, and then challenged myself to only use the fish shell for a week. 
</p>

<p>
<code>NOTE</code>: <i>For those wanting to try out fish for themselves, you can find download instructions on fish's <a href="https://fishshell.com">main page</a>. Then, simply type <code>fish</code> into your shell and you're good to go! If you wish to set fish as your default shell, simply type <code>[sudo] chsh -s [path_to_fish]</code> and then restart your computer or log off/on.</i>
</p>

<p>
To ensure each subsequent shell I opened up was running fish, the first command that I ran was <code>sudo chsh -s $(which fish)</code> to set the fish shell as my default shell. After a quick restart I was ready to begin. There were several things I noticed almost immediately after I began typing a command: both autosuggestions and syntax highlighting were available out of the box. In fact, in less than 30 seconds I discovered that every single plugin that I configured for my Zsh configuration was available by default in the fish shell, with zero configuration required. Default configuration included autosuggestions, syntax highlighting, history substring searching, and even descriptions for command options when using autocompletions. fish even has a default welcome message when launching the shell, and by simply typing <code>help</code> the documentation opens up directly in your web browser! I immediately dove into the documentation and began exploring everything the fish shell had to offer. 
</p>

<p>
<code>NOTE</code>: <i>fish shell, or the <b>friendly interactive shell</b>, was first released in early 2005, a little over 18 years ago. It's not exactly the newest shell to date, especially when compared to other non-POSIX shells like Nushell, but it's over two decades younger than Bash and Zsh (which were released in 1989 and 1990, respectively).</i>
</p>

<p>
One of my initial goals when I began using fish was to replicate the environment I had created in Zsh, including some custom Bash functions that I wrote, a few helpful aliases, and adding to my PATH environment variable to allow the execution of certain binaries located inside <code>~/.local/bin/</code>, such as ipython, jupyter notebooks, and several language servers that I use to power the autocompletion backend in the Emacs text editor. Since fish is not a POSIX-compliant shell (this is by design), there were several differences I encountered:
</p>

<ul class="org-ul">
<li>fish has it's own programming language that is <b>not</b> POSIX-compliant. If you don't have the fish shell installed as an executable on your system, you won't be able to run scripts or programs written in the fish language.</li>

<li>The <code>functions</code> command allows a user to view all the functions available in the fish shell, including custom functions written by the user. If the user types <code>functions [function_name]</code>, the fish code for that function is returned as the output. The <code>functions</code> command is similar to that of Zsh, but in my opinion the fish implementation feels much more practical.</li>

<li>Custom functions, written by the user, can be created and saved directly in the shell. After defining a custom function, running <code>funcsave [function_name]</code> saves the function to <code>~/.config/fish/functions/function_name.fish</code> to be autoloaded by any current and future fish sessions.</li>

<li>There are no built-in iterators for creating ranges in the fish language. (For those of you who know me personally, you would know that I <i>love</i> built-in iterators). Instead of using a common Bash idiom such as <code>for i in {1..10}</code>, fish relies on calling external commands like <code>for i in (seq 10)</code> to create an iterator.</li>

<li>Command substitution can be performed via ( ) or $( ), in contrast to Bash's ` ` and $( ) syntax.</li>

<li>All variables in fish are lists (or arrays, professionally speaking), and list indices start at index 1. This is in contrast to most programming languages, which start at index 0. This is by design: fish uses <code>$argv[..]</code> to access arguments passed into a function, instead of Bash's <code>$1</code>, <code>$2</code>, etc. This design choice requires less subtracting of 1 and many common Unix tools like <code>seq</code> <i>arguably</i> work better with it. For instance, <code>seq 5</code> prints 1 to 5, not 0 to 5. Also, there are no nested lists. Instead, fish opts to using the dereference operator (<code>$</code>) to dereference variables, functioning similar to references in C.</li>
</ul>

<p>
<code>NOTE</code>: <i>If you're trying out fish and looking for some helpful fish functions, check out <a href="https://github.com/Tdback/Helpful-Shell-Functions">this</a> GitHub repository. Here you'll find both aliases and custom functions that I oftentimes use to save some typing and improve my terminal workflow.</i>
</p>

<p>
It only took a few hours of reading through the (dare I say incredible) documentation to get acclimated with the fish language and shell environment. In fact, fish's documentation system is one of the shell's most powerful features. For me, documentation is a very important aspect when using a tool or language. It is usually my first instinct to read through a command's man page or quickly skim over examples to understand how to properly use the command. fish has several ways for the user to access documentation, including official Linux man pages, online documentation located on the official website, and a very powerful help system through the use of the <code>help</code> command (you never would have guessed). If you have an internet connection and want immediate access to the entirety of fish's documentation, just type <code>help [...]</code> in your terminal and it will open up the query directly in your web browser! This is very similar to the <code>Help</code> system in Microsoft's PowerShell, which I equally enjoy. As previously mentioned, there are also several man pages available that directly translate to the online documentation. These include commands like <code>man fish</code>, <code>man fish-language</code>, and <code>man fish-interactive</code>. I feel that this system sits in between the Bash man pages and perldocs (hello any Perl users out there, you'll know what I mean), where the complete documentation for the entire fish shell and language can be accessed directly from your terminal, even without an internet connection. And to top it all off, the fish shell has an incredible tutorial. It acts as both a simple walkthrough to accomodate new users, and also has specific sections for both veteran Bash and Zsh users to demonstrate the key differences between the fish shell and its alternatives. The magic phrase <i>unlike other shells</i> is something a Bash user should keep their eyes peeled for throughout the tutorial.
</p>

<p>
fish in its very essence is user friendly. But this does not mean an experienced terminal wizard would not benefit from the many features fish has to offer. It was designed to be ready to use immediately, without the need for extensive configuration or forcing the user to learn arcane syntax (their words, not mine). As previously mentioned, fish ships out of the box with a wealth of powerful features: syntax highlighing, autosuggestions, and tab completions to just name a few. Out of all the features, the most notable to me is autosuggestions. At times it feels like the shell knows what I want to type before <i>I</i> even do. This is because autosuggestions suggest commands based on command history, completions, and valid file paths. So, if you were to type a really long file path over and over again, fish will suggest it the next time you try to type it. Autosuggestions can also be completed via the right arrow key (or Control-f), using Alt-f to complete only the next suggested word, or ignored altogether. Using autosuggestions <i>feels</i> magical. I highly recommend giving this feature a try. In fact, I cannot recommend it enough. One minor grievance I have is the lack of support for using Control- and Alt-f out of the box with vi mode enabled. If the user wishes to use those keybinds, they have to write their own custom fish function to handle those hotkeys (so naturally I did). Aside from the addition of autosuggestions, fish also expands on the functionality of tab-completions. When using tab to autocomplete a command option, fish provides completion descriptions for each option. If there is a list of options availabe, the user can utilize the arrow keys to navigate through the list of available completions. Finally, there is syntax highlighting. This feature of the fish shell breathes new life into the terminal. I highly recommend that you try it for yourself, especially if you are used to staring at the black and white default colorscheme oftentimes found in the Bash shell. As humans, we have been associating colors with meaning since we were born, so why not take advantage of it in your terminal? fish's support for syntax highlighting makes errors much easier to identify instead of hunting for them in an error message. fish has a rich set of color schemes, which can be configured using the <code>fish_config</code> command or directly from the browser. Yes, you read that right: fish can be completely configured from the "comfort" of your web browser if you do so desire. In addition, many of these features can be disabled directly in the shell by manipulating several built-in environment variables. If you don't like autosuggestions, just disable them by setting <code>$fish_autosuggestion_enabled</code> to 0!
</p>

<p>
What about drawbacks? One word: portability. As previously mentioned, fish is <b>not</b> a POSIX-compliant shell, nor does it try to be. If I were to write a simple script in fish that were to detect what Linux distribution you were on (e.g. Arch, Debian, Fedora) and then run the respective package manager to check for any available package updates, if <i>you</i> didn't have fish installed on your system you simply couldn't run the script. In contrast, if I were to write a Bash script that would accomplish the same thing, if you were running a Linux or Unix system you'd be able to run it! This is because unlike Bash, fish does not come installed by default on operating systems, nor support the same syntax and language features. This, for some, is the main reason they do not use fish: they value portability and uniformity over convenience and features. <i>However</i>, this does not deter me from using the fish shell. You can still write and readily execute Bash scripts within your fish shell. The only difference is that most of the configuration is written in fish, in contrast to Bash. Having written my entire Emacs configuration in Emacs Lisp and org-mode, I have no issue with writing my entire shell configuration in fish, or any language for that matter.
</p>

<p>
<code>NOTE</code>: <i>If you would like to learn more about the POSIX standard, with a dash of Unix history, look <a href="https://itsfoss.com/posix/">here</a>.</i> 
</p>

<p>
After one week of using fish, I have no inclination to return to using Zsh (or Bash) as the default shell on my system(s). fish's rich set of features, simple language syntax, and the feeling of sheer joy I have when using this terminal have all backed my decision to continue using it. As of now, I much prefer fish to any of the alternatives that I have used, but one day another shell may come along that I'll try and like even more than fish. I highly recommend that you try fish out for yourself, and if you do, feel free to reach out letting me know how your experience with it went!
</p>

<p>
<i>Until next time, hack away, hack away my friends!</i>
</p>
</div>
<div id="postamble" class="status">
<p class="creator"><a href="https://www.gnu.org/software/emacs/">Emacs</a> 27.1 (<a href="https://orgmode.org">Org</a> mode 9.3)</p>
</div>
</body>
</html>
